/**
 * BLE HID Keyboard for ESPHome — direct Bluedroid GATTS API.
 */
#include "espidf_ble_keyboard.h"
#include "esphome/core/log.h"
#include "esphome/core/hal.h"
#include "freertos/FreeRTOS.h"
#include "freertos/task.h"
#include "esp_gatt_defs.h"
#include "esp_bt_defs.h"
#include <cstring>

namespace esphome {
namespace espidf_ble_keyboard {

static const char *TAG = "espidf_ble_keyboard";
static EspidfBleKeyboard *s_instance = nullptr;
static bool s_service_started = false;

// ── HID Report Descriptor ────────────────────────────────────────────────────
static const uint8_t hid_report_map[] = {
    0x05, 0x01, 0x09, 0x06, 0xA1, 0x01,
    0x85, 0x01,  // Report ID 1
    0x05, 0x07, 0x19, 0xE0, 0x29, 0xE7,
    0x15, 0x00, 0x25, 0x01, 0x75, 0x01, 0x95, 0x08, 0x81, 0x02,
    0x95, 0x01, 0x75, 0x08, 0x81, 0x01,
    0x95, 0x05, 0x75, 0x01, 0x05, 0x08, 0x19, 0x01, 0x29, 0x05, 0x91, 0x02,
    0x95, 0x01, 0x75, 0x03, 0x91, 0x01,
    0x95, 0x06, 0x75, 0x08, 0x15, 0x00, 0x25, 0x65,
    0x05, 0x07, 0x19, 0x00, 0x29, 0x65, 0x81, 0x00,
    0xC0
};

// ── GATT ─────────────────────────────────────────────────────────────────────
#define GATTS_APP_ID    0x55
#define HID_NUM_HANDLES 22

static esp_gatt_if_t s_gatts_if = ESP_GATT_IF_NONE;
static uint16_t s_hid_report_handle = 0;

// Raw advertising packet — built manually to avoid esp_ble_gap_config_adv_data issues
// Format: [len, type, data, ...]
// Flags: 0x02 len, 0x01 type, 0x06 value (LE General Discoverable, BR/EDR not supported)
// Appearance: 0x03 len, 0x19 type, 0xC1 0x03 (HID Keyboard = 0x03C1)
// UUID16: 0x03 len, 0x03 type (Complete List), 0x12 0x18 (HID = 0x1812)
static uint8_t raw_adv_data[] = {
    0x02, 0x01, 0x06,           // Flags: LE General Discoverable, no BR/EDR
    0x03, 0x19, 0xC1, 0x03,     // Appearance: HID Keyboard (0x03C1)
    0x03, 0x03, 0x12, 0x18,     // Complete UUID16 list: HID service (0x1812)
};

// Raw scan response — just the device name
// Name will be set dynamically via esp_ble_gap_config_raw_scan_rsp_data
static uint8_t raw_scan_rsp_data[] = {
    0x11, 0x09,  // length=17, type=Complete Local Name
    'E','S','P','3','2',' ','B','L','E',' ','K','e','y','b','o','a','r','d'
};  // "ESP32 BLE Keyboard" = 18 chars, so length byte = 19... let me fix

static esp_ble_adv_params_t adv_params = {
    .adv_int_min       = 0x20,
    .adv_int_max       = 0x40,
    .adv_type          = ADV_TYPE_IND,
    .own_addr_type     = BLE_ADDR_TYPE_PUBLIC,
    .channel_map       = ADV_CHNL_ALL,
    .adv_filter_policy = ADV_FILTER_ALLOW_SCAN_ANY_CON_ANY,
};

// Raw advertising packet for ESP-IDF 5.x extended advertising API
// Format: [len, type, data, ...]
static uint8_t adv_data_raw[] = {
    0x02, 0x01, 0x06,           // Flags: LE General Discoverable, no BR/EDR
    0x03, 0x19, 0xC1, 0x03,     // Appearance: HID Keyboard (0x03C1)
    0x03, 0x03, 0x12, 0x18,     // Complete UUID16 list: HID service (0x1812)
};

// Raw scan response packet
static uint8_t scan_rsp_raw[] = {
    0x11, 0x09, 'E','S','P','3','2',' ','B','L','E',' ','K','e','y','b','o','a','r','d'
};

static void do_start_advertising() {
    // In ESP-IDF 5.x, use extended advertising API
    esp_err_t r1 = esp_ble_ext_adv_set_data(adv_data_raw, sizeof(adv_data_raw));
    esp_err_t r2 = esp_ble_ext_adv_set_scan_rsp_data(scan_rsp_raw, sizeof(scan_rsp_raw));

    ESP_LOGI(TAG, "GAP: ext adv set=0x%x scan rsp set=0x%x", r1, r2);
    if (r1 != ESP_OK || r2 != ESP_OK) {
        ESP_LOGE(TAG, "GAP: extended advertising setup failed");
        return;
    }
    
    // Start extended advertising
    esp_err_t r3 = esp_ble_ext_adv_start(0);  // instance 0
    if (r3 != ESP_OK) {
        ESP_LOGE(TAG, "GAP: ext adv start failed: %d", r3);
    } else {
        ESP_LOGI(TAG, "GAP: extended advertising started");
    }
}

// ── GAP event handler ─────────────────────────────────────────────────────────
static void gap_event_handler(esp_gap_ble_cb_event_t event, esp_ble_gap_cb_param_t *param) {
    switch (event) {
        case ESP_GAP_BLE_ADV_DATA_SET_COMPLETE_EVT:
            ESP_LOGI(TAG, "GAP: adv data set");
            break;

        case ESP_GAP_BLE_SCAN_RSP_DATA_SET_COMPLETE_EVT:
            ESP_LOGI(TAG, "GAP: scan rsp set, starting advertising");
            esp_ble_gap_start_advertising(&adv_params);
            break;

        case ESP_GAP_BLE_ADV_START_COMPLETE_EVT:
            if (param->adv_start_cmpl.status == ESP_BT_STATUS_SUCCESS) {
                ESP_LOGI(TAG, "GAP: advertising started — 'ESP32 BLE Keyboard' now visible");
            } else {
                ESP_LOGE(TAG, "GAP: advertising start failed: %d", param->adv_start_cmpl.status);
            }
            break;

        case ESP_GAP_BLE_ADV_STOP_COMPLETE_EVT:
            ESP_LOGI(TAG, "GAP: advertising stopped");
            break;

        case ESP_GAP_BLE_UPDATE_CONN_PARAMS_EVT:
            ESP_LOGI(TAG, "GAP: conn params updated");
            break;

        default:
            ESP_LOGD(TAG, "GAP event: %d", (int)event);
            break;
    }
}

// ── GATT attribute table ─────────────────────────────────────────────────────
enum {
    IDX_SVC,
    IDX_CHAR_HID_INFO,     IDX_CHAR_HID_INFO_VAL,
    IDX_CHAR_REPORT_MAP,   IDX_CHAR_REPORT_MAP_VAL,
    IDX_CHAR_HID_CTRL,     IDX_CHAR_HID_CTRL_VAL,
    IDX_CHAR_PROTO_MODE,   IDX_CHAR_PROTO_MODE_VAL,
    IDX_CHAR_REPORT,       IDX_CHAR_REPORT_VAL,
    IDX_CHAR_REPORT_CCC,
    IDX_CHAR_REPORT_REF,
    HID_IDX_NB,
};

static uint16_t hid_handle_table[HID_IDX_NB];

static uint8_t  hid_info_val[4]   = {0x11, 0x01, 0x00, 0x01};
static uint8_t  hid_ctrl_val      = 0;
static uint8_t  proto_mode_val    = 0x01;
static uint8_t  report_val[8]     = {0};
static uint16_t report_ccc_val    = 0;
static uint8_t  report_ref_val[2] = {0x01, 0x01};

static const uint16_t UUID_PRI_SERVICE        = ESP_GATT_UUID_PRI_SERVICE;
static const uint16_t UUID_HID_SVC            = ESP_GATT_UUID_HID_SVC;
static const uint16_t UUID_CHAR_DECLARE       = ESP_GATT_UUID_CHAR_DECLARE;
static const uint16_t UUID_HID_INFORMATION    = ESP_GATT_UUID_HID_INFORMATION;
static const uint16_t UUID_HID_REPORT_MAP     = ESP_GATT_UUID_HID_REPORT_MAP;
static const uint16_t UUID_HID_CONTROL_POINT  = ESP_GATT_UUID_HID_CONTROL_POINT;
static const uint16_t UUID_HID_PROTO_MODE     = ESP_GATT_UUID_HID_PROTO_MODE;
static const uint16_t UUID_HID_REPORT         = ESP_GATT_UUID_HID_REPORT;
static const uint16_t UUID_CHAR_CLIENT_CONFIG = ESP_GATT_UUID_CHAR_CLIENT_CONFIG;
static const uint16_t UUID_RPT_REF_DESCR      = ESP_GATT_UUID_RPT_REF_DESCR;

static const uint8_t PROP_READ        = ESP_GATT_CHAR_PROP_BIT_READ;
static const uint8_t PROP_WRITE_NR    = ESP_GATT_CHAR_PROP_BIT_WRITE_NR;
static const uint8_t PROP_RW_NR       = ESP_GATT_CHAR_PROP_BIT_READ | ESP_GATT_CHAR_PROP_BIT_WRITE_NR;
static const uint8_t PROP_READ_NOTIFY = ESP_GATT_CHAR_PROP_BIT_READ | ESP_GATT_CHAR_PROP_BIT_NOTIFY;

static const esp_gatts_attr_db_t hid_attr_db[HID_IDX_NB] = {
    [IDX_SVC] = {
        {ESP_GATT_AUTO_RSP},
        {ESP_UUID_LEN_16, (uint8_t *)&UUID_PRI_SERVICE, ESP_GATT_PERM_READ,
         sizeof(uint16_t), sizeof(uint16_t), (uint8_t *)&UUID_HID_SVC}
    },
    [IDX_CHAR_HID_INFO] = {
        {ESP_GATT_AUTO_RSP},
        {ESP_UUID_LEN_16, (uint8_t *)&UUID_CHAR_DECLARE, ESP_GATT_PERM_READ, 1, 1, (uint8_t *)&PROP_READ}
    },
    [IDX_CHAR_HID_INFO_VAL] = {
        {ESP_GATT_AUTO_RSP},
        {ESP_UUID_LEN_16, (uint8_t *)&UUID_HID_INFORMATION, ESP_GATT_PERM_READ,
         sizeof(hid_info_val), sizeof(hid_info_val), hid_info_val}
    },
    [IDX_CHAR_REPORT_MAP] = {
        {ESP_GATT_AUTO_RSP},
        {ESP_UUID_LEN_16, (uint8_t *)&UUID_CHAR_DECLARE, ESP_GATT_PERM_READ, 1, 1, (uint8_t *)&PROP_READ}
    },
    [IDX_CHAR_REPORT_MAP_VAL] = {
        {ESP_GATT_AUTO_RSP},
        {ESP_UUID_LEN_16, (uint8_t *)&UUID_HID_REPORT_MAP, ESP_GATT_PERM_READ,
         sizeof(hid_report_map), sizeof(hid_report_map), (uint8_t *)hid_report_map}
    },
    [IDX_CHAR_HID_CTRL] = {
        {ESP_GATT_AUTO_RSP},
        {ESP_UUID_LEN_16, (uint8_t *)&UUID_CHAR_DECLARE, ESP_GATT_PERM_READ, 1, 1, (uint8_t *)&PROP_WRITE_NR}
    },
    [IDX_CHAR_HID_CTRL_VAL] = {
        {ESP_GATT_AUTO_RSP},
        {ESP_UUID_LEN_16, (uint8_t *)&UUID_HID_CONTROL_POINT, ESP_GATT_PERM_WRITE, 1, 1, &hid_ctrl_val}
    },
    [IDX_CHAR_PROTO_MODE] = {
        {ESP_GATT_AUTO_RSP},
        {ESP_UUID_LEN_16, (uint8_t *)&UUID_CHAR_DECLARE, ESP_GATT_PERM_READ, 1, 1, (uint8_t *)&PROP_RW_NR}
    },
    [IDX_CHAR_PROTO_MODE_VAL] = {
        {ESP_GATT_AUTO_RSP},
        {ESP_UUID_LEN_16, (uint8_t *)&UUID_HID_PROTO_MODE,
         ESP_GATT_PERM_READ | ESP_GATT_PERM_WRITE, 1, 1, &proto_mode_val}
    },
    [IDX_CHAR_REPORT] = {
        {ESP_GATT_AUTO_RSP},
        {ESP_UUID_LEN_16, (uint8_t *)&UUID_CHAR_DECLARE, ESP_GATT_PERM_READ, 1, 1, (uint8_t *)&PROP_READ_NOTIFY}
    },
    [IDX_CHAR_REPORT_VAL] = {
        {ESP_GATT_AUTO_RSP},
        {ESP_UUID_LEN_16, (uint8_t *)&UUID_HID_REPORT, ESP_GATT_PERM_READ,
         sizeof(report_val), sizeof(report_val), report_val}
    },
    [IDX_CHAR_REPORT_CCC] = {
        {ESP_GATT_AUTO_RSP},
        {ESP_UUID_LEN_16, (uint8_t *)&UUID_CHAR_CLIENT_CONFIG,
         ESP_GATT_PERM_READ | ESP_GATT_PERM_WRITE,
         sizeof(report_ccc_val), sizeof(report_ccc_val), (uint8_t *)&report_ccc_val}
    },
    [IDX_CHAR_REPORT_REF] = {
        {ESP_GATT_AUTO_RSP},
        {ESP_UUID_LEN_16, (uint8_t *)&UUID_RPT_REF_DESCR, ESP_GATT_PERM_READ,
         sizeof(report_ref_val), sizeof(report_ref_val), report_ref_val}
    },
};

// ── GATTS event handler ───────────────────────────────────────────────────────
static void gatts_event_handler(esp_gatts_cb_event_t event, esp_gatt_if_t gatts_if,
                                 esp_ble_gatts_cb_param_t *param) {
    switch (event) {
        case ESP_GATTS_REG_EVT:
            ESP_LOGI(TAG, "GATTS: registered");
            s_gatts_if = gatts_if;
            esp_ble_gap_set_device_name("ESP32 BLE Keyboard");
            esp_ble_gatts_create_attr_tab(hid_attr_db, gatts_if, HID_IDX_NB, 0);
            break;

        case ESP_GATTS_CREAT_ATTR_TAB_EVT:
            if (param->add_attr_tab.status != ESP_GATT_OK ||
                param->add_attr_tab.num_handle != HID_IDX_NB) {
                ESP_LOGE(TAG, "GATTS: attr tab error status=%d handles=%d",
                         param->add_attr_tab.status, param->add_attr_tab.num_handle);
                break;
            }
            memcpy(hid_handle_table, param->add_attr_tab.handles, sizeof(hid_handle_table));
            s_hid_report_handle = hid_handle_table[IDX_CHAR_REPORT_VAL];
            ESP_LOGI(TAG, "GATTS: attr table created, starting service");
            esp_ble_gatts_start_service(hid_handle_table[IDX_SVC]);
            break;

        case ESP_GATTS_START_EVT:
            ESP_LOGI(TAG, "GATTS: HID service started — starting advertising");
            s_service_started = true;
            do_start_advertising();
            break;

        case ESP_GATTS_CONNECT_EVT: {
            ESP_LOGI(TAG, "GATTS: connected conn_id=%d", param->connect.conn_id);
            if (s_instance) s_instance->set_connected(true, param->connect.conn_id);
            esp_ble_conn_update_params_t cp = {};
            memcpy(cp.bda, param->connect.remote_bda, sizeof(esp_bd_addr_t));
            cp.latency = 0;
            cp.min_int = 0x10;
            cp.max_int = 0x20;
            cp.timeout = 400;
            esp_ble_gap_update_conn_params(&cp);
            break;
        }

        case ESP_GATTS_DISCONNECT_EVT:
            ESP_LOGI(TAG, "GATTS: disconnected — restarting advertising");
            if (s_instance) s_instance->set_connected(false, 0);
            esp_ble_gap_start_advertising(&adv_params);
            break;

        case ESP_GATTS_WRITE_EVT:
            if (param->write.handle == hid_handle_table[IDX_CHAR_REPORT_CCC]) {
                ESP_LOGI(TAG, "GATTS: notifications %s",
                         (param->write.value[0] == 0x01) ? "enabled" : "disabled");
            }
            break;

        case ESP_GATTS_MTU_EVT:
            ESP_LOGI(TAG, "GATTS: MTU=%d", param->mtu.mtu);
            break;

        default:
            break;
    }
}

// ── Component setup / loop ───────────────────────────────────────────────────
void EspidfBleKeyboard::setup() {
    s_instance = this;
    ESP_LOGI(TAG, "BLE HID Keyboard setup starting");

    esp_err_t ret = nvs_flash_init();
    if (ret == ESP_ERR_NVS_NO_FREE_PAGES || ret == ESP_ERR_NVS_NEW_VERSION_FOUND) {
        ESP_ERROR_CHECK(nvs_flash_erase());
        ret = nvs_flash_init();
    }
    ESP_ERROR_CHECK(ret);

    // Fix the raw scan response length byte — name is 18 chars
    raw_scan_rsp_data[0] = 1 + 18;  // type byte + 18 char name

    ESP_ERROR_CHECK(esp_bt_controller_mem_release(ESP_BT_MODE_CLASSIC_BT));

    esp_bt_controller_config_t bt_cfg = BT_CONTROLLER_INIT_CONFIG_DEFAULT();
    ESP_ERROR_CHECK(esp_bt_controller_init(&bt_cfg));
    ESP_ERROR_CHECK(esp_bt_controller_enable(ESP_BT_MODE_BLE));
    ESP_ERROR_CHECK(esp_bluedroid_init());
    ESP_ERROR_CHECK(esp_bluedroid_enable());

    ESP_ERROR_CHECK(esp_ble_gap_register_callback(gap_event_handler));
    ESP_ERROR_CHECK(esp_ble_gatts_register_callback(gatts_event_handler));
    ESP_ERROR_CHECK(esp_ble_gatts_app_register(GATTS_APP_ID));

    ESP_LOGI(TAG, "BLE HID Keyboard setup complete");
}

void EspidfBleKeyboard::loop() {}

// ── Input reporting ──────────────────────────────────────────────────────────
void EspidfBleKeyboard::send_string(const std::string &str) {
    if (!is_connected_) {
        ESP_LOGW(TAG, "send_string: not connected");
        return;
    }
    uint8_t report[8] = {0};
    for (char c : str) {
        report[0] = 0x00;
        report[2] = 0x00;
        if      (c >= 'a' && c <= 'z') { report[2] = (uint8_t)(c - 'a' + 0x04); }
        else if (c >= 'A' && c <= 'Z') { report[0] = 0x02; report[2] = (uint8_t)(c - 'A' + 0x04); }
        else if (c == ' ')  { report[2] = 0x2C; }
        else if (c == '\n') { report[2] = 0x28; }
        else if (c == '\t') { report[2] = 0x2B; }
        else if (c == '.')  { report[2] = 0x37; }
        else if (c == ',')  { report[2] = 0x36; }
        else if (c == '!')  { report[0] = 0x02; report[2] = 0x1E; }
        else { continue; }

        esp_ble_gatts_send_indicate(s_gatts_if, conn_id_, s_hid_report_handle,
                                    sizeof(report), report, false);
        vTaskDelay(pdMS_TO_TICKS(20));
        memset(report, 0, sizeof(report));
        esp_ble_gatts_send_indicate(s_gatts_if, conn_id_, s_hid_report_handle,
                                    sizeof(report), report, false);
        vTaskDelay(pdMS_TO_TICKS(20));
    }
}

void EspidfBleKeyboard::send_ctrl_alt_del() {
    if (!is_connected_) {
        ESP_LOGW(TAG, "send_ctrl_alt_del: not connected");
        return;
    }
    uint8_t report[8] = {0};
    report[0] = 0x05;
    report[2] = 0x4C;
    esp_ble_gatts_send_indicate(s_gatts_if, conn_id_, s_hid_report_handle,
                                sizeof(report), report, false);
    vTaskDelay(pdMS_TO_TICKS(50));
    memset(report, 0, sizeof(report));
    esp_ble_gatts_send_indicate(s_gatts_if, conn_id_, s_hid_report_handle,
                                sizeof(report), report, false);
}

void EspidfBleKeyboardButton::press_action() {
    if (parent_ == nullptr) { ESP_LOGE(TAG, "parent not set"); return; }
    if (action_ == "ctrl_alt_del") parent_->send_ctrl_alt_del();
    else parent_->send_string(action_);
}

}  // namespace espidf_ble_keyboard
}  // namespace esphome
